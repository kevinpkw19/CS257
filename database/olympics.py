import argparse
import psycopg2

from config import database
from config import user
from config import password


def connect_to_database(input):
    # Connect to the database
    try:
        connection = psycopg2.connect(database=database, user=user, password=password)
    except Exception as e:
        print(e)
        exit()

    # Query the database, leaving you with a "cursor"--an object you can
    # use to iterate over the rows generated by your query.
    try:
        cursor = connection.cursor()
        query = 'SELECT athlete_info.athlete_name FROM athlete_info, team_info, noc_info WHERE athlete_info.athlete_name LIKE "{}%" AND athlete_info.team_id = team_info.team_id AND team_info.noc_id = noc_info.noc_id AND ORDER BY athlete_info.athlete_name'.format(input)
        cursor.execute(query)
    except Exception as e:
        print(e)
        exit()

    # We have a cursor now. Iterate over its rows to print the results.
    print('===== All athletes from {} ====='.format(input))
    for row in cursor:
        print(row[0])
    print()

    # # Do you have information provided by your user (e.g. a search string)
    # # that needs to go into your SQL query? Since you can't trust users
    # # not to be malicious, you need to be very careful about how you use
    # # any input they provide. To avoid the very common and very dangerous
    # # security attack known as "SQL Injection", use the parameterized version of
    # # cursor.execute, like this. (We'll discuss SQL Injection in detail soon.)
    # search_string = 'BrontÃ«'
    # query = '''SELECT first_name, last_name
    #         FROM authors
    #         WHERE last_name = %s'''
    # try:
    #     cursor.execute(query, (search_string,))
    # except Exception as e:
    #     print(e)
    #     exit()

    # print('===== Authors with last name {0} ====='.format(search_string))
    # for row in cursor:
    #     print(row[0], row[1])
    # print()

    # Don't forget to close the database connection.
    connection.close()


def list_athletes_by_noc():
    pass



def get_arguments():
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group()
    group.add_argument("--abn", action="store_true", help = "Accepts a National Olympic Committee(NOC) as the parameter and                                                                 returns a list of all the athletes from that NOC")
    group.add_argument("--nbg", action="store_true", help = "Lists all National Olympic Committees(NOC) by decreasing gold medal                                                            count")
    group.add_argument("--gba", action="store_true", help = "Accepts an athlete's name as a parameter and lists their gold medal                                                            count.")
    parser.add_argument("Input", nargs="*", type=str, help = "for --abn, provide an NOC. for --gba, provide athlete name.")

    args = parser.parse_args()

    return args

def main():
    args = get_arguments()
    
    # If user writes command without input, print error message
    if len(args.Input) == 0:
        if args.nbg:
            # execute somethng
            print("nbg")
        else:
            print("Your must use --nbg if you don't provide any input parameters.")

    # checks the number of inputs given by user and prints error message accordingly
    elif len(args.Input) == 1:
        if args.gba:
            print("gba")
        elif args.abn:
            connect_to_database(args.Input)
            
    else:
        print("Error. Too many arguments.")


main()